#summary QTable_Link 封装了数据表关联操作

= 什么叫做关联 =

数据表关联是指两个或者多个数据表的*记录之间的逻辑关系* 。

比如一篇文章（一篇文章保存为“文章”数据表的一条记录）有多个评论（一个评论保存为“评论”数据表的一条记录）。那么就可以说“文章”对于“评论”是一个 *“一对多”* 的关系。

从现实角度，只有“一对一”和“一对多”两种关系。但由于关系式数据库不能直接存储数据之间的关系，所以两种关系扩展为 *“一对一”* 、 *“一对多”* 、 *“从属”* 和 *“多对多”* 四种关系。

如果加上更多的限制条件，四种关联还可以扩展出更多类型的关联。例如“一对多”通常表示一个事物 *“拥有（HAS）”* 多个其他事物，但有时也可以表示一个事物和多个事物相关，但并不能够决定这些事物的存在。

典型的例子就是文章与评论。文章“拥有”多个评论，因为评论是不能单独存在的，必定是属于一个文章。但同样是“一对多”，一个分类对应多个商品就不同。虽然商品必定属于一个分类，但是在删除分类时，如果有属于该分类的商品，要么是禁止删除分类，要么是将属于该分类的商品划分到另一个分类。

四种关联的特点、区别以及适用场合，会在后面的内容详细说明。

= QeePHP 对四种关联的支持 =

QTable_Link 对四种数据表关联提供了全面的支持，包括自动查询关联数据、自动创建关联数据，以及维护关联关系等特征。

对于所有类型的关联，都支持以下功能：

 * 查询主表时，自动查询关联表数据
 * 查询关联表数据时，进行排序
 * 查询关联表数据时，使用字段别名
 * 可以指定要查询的关联表字段
 * 可以指定查询关联表时要使用的查询条件
 * 可以限定查询关联表时返回的记录数
 * 可以在删除主表记录时，自动删除关联表的记录
 * 可以在创建主表记录时，自动创建关联表的记录

不过四种关联在对各项功能的支持上，具有不同的默认设置：

 * has one 一对一
 * has many 一对多
  * 创建主表记录时，如果包含关联表记录，则自动创建关联表记录
  * 删除主表记录时，自动删除关联的记录

 * belongs to 从属
  * 不会自动创建关联记录
  * 不会自动删除关联的记录

 * many to many 多对多
  * 自动创建关联记录
  * 自动通过中间表维护主表和关联表之间的关系
  * 不会自动删除关联的记录

= 如何定义一个关联 =

在定义一个数据表的关联时，通过表数据入口继承类的 $has_one、$has_many、$belongs_to 和 $many_to_many 进行。

例如：

{{{
/**
 * Table_Contents 类封装了 contents 表的操作以及与相关表的关联操作
 */
class Table_Contents extends QTable_Base
{
    /**
     * 不包含全局前缀的数据表名称
     *
     * @var string
     */
    public $table_name = 'contents';

    /**
     * 主键字段名
     *
     * @var string
     */
    public $pk = 'content_id';

    /**
     * belongs to 关联
     *
     * @var array
     */
    protected $belongs_to = array(
        /**
         * 每个内容都有一个作者
         */
        array(
            /**
             * 指示关联到哪一个表数据入口类
             */
            'table_class'   => 'Table_Authors',

            /**
             * 指示关联的名称，以及关联数据在保存主表记录的数组中用什么名字引用
             */
            'mapping_name'  => 'author',

            /**
             * 指示在主表中用什么字段和关联表记录进行关联
             */
            'main_key'      => 'author_id',

            /**
             * 指示在 Table_Authors 封装的数据表中使用什么字段存储关联内容的记录总数
             */
            'count_cache'   => 'contents_count',

            /**
             * 指示在读取作者信息时，只获取作者表的哪些字段
             */
            'on_find_fields' => array('author_id', 'name' => 'name_alias'),
        ),
    );
}
}}}

因为有可能需要定义多个同一种类型的关联，所以 $has_one、$has_many、$belongs_to 和 $many_to_many 成员变量的格式都是一个二维数组。

{{{
protected $has_one = array(
    // 第一个 has one 关联
    array(
        .....
    ),

    // 第二个 has one 关联
    array(
        .....
    ),
);
}}}

== 定义关联时可以指定的选项 ==

定义关联时，可以指定不同的选项，从而改变关联的行为。

可用的选项如下：

{{{
'assoc_table_obj'
    关联的表数据入口对象实例

'assoc_table_class'
    关联到哪一个表数据入口类

'assoc_table_name'
    关联到哪一个数据表

    'assoc_table_obj'、'assoc_table_class'、'assoc_table_name' 三者只需要指定一个，三者的优先级从上到下。
    如果 'assoc_table_name' 有效，则可以通过 'assoc_table_????' 等一系列参数指示构造关联表数据入口时的选项。
    可用的 'assoc_table_????' 系列选项有：

    'assoc_table_pk'        关联数据表的主键
    'assoc_table_schema'    关联数据表所属 schema

'mapping_name'
    关联的名称，以及关联数据在保存主表记录的数组中用什么名字引用

'main_key'
    指示在主表中用什么字段和关联表记录进行关联
    对于 has many 和 has one 关联，'main_key' 的默认值是主表的主键字段
    对于 belongs to 关联，'main_key' 的默认值是主表中与关联表主键字段同名的字段
    对于 many to many 关联，'main_key' 的默认值是主表的主键字段

'assoc_key'
    关联关系在关联表中使用哪一个字段
    对于 has many、has one 关联，'assoc_key' 的默认值是关联表中与主表主键字段同名的字段
    对于 belongs to 关联，'assoc_key' 的默认值是关联表的主键字段
    对于 many to many 关联，'assoc_key' 的默认值是关联表的主键字段

'mid_main_key' （可选，仅用于 many to many 关联）
    指示在中间表中，用哪个字段存储对主表的 'main_key' 引用
    'mid_main_key' 的默认值是中间表中与 'main_key' 同名的字段

'mid_assoc_key' （可选，仅用于 many to many 关联）
    指示在中间表中，用哪个字段存储对关联表的 'assoc_key' 引用
    'mid_assoc_key' 的默认值是中间表中与 'assoc_key' 同名的字段

'mid_table_obj'
    中间表的表数据入口对象实例

'mid_table_class' （仅用于 many to many 关联）
    指示用哪一个表数据入口对象封装对中间表的操作

'mid_table_name' （仅用于 many to many 关联）
    指示中间表的名称（不含前缀）
    'mid_table_obj'、'mid_table_class'、'mid_table_name' 三者只需要指定一个，三者的优先级从上到下。
    如果 'mid_table_name' 有效，则可以通过 'mid_table_????' 等一系列参数指示构造关联表数据入口时的选项。

'mid_on_find_fields'
    指示查询 many to many 关联时，中间表的哪些字段要包含在查询结果中
    空字符串 或 null - 不查询中间表的字段
    *                - 查询中间表的所有字段
    字段列表         - 以逗号分隔的字段名或者包含字段名的数组

    'mid_on_find_fields' 的默认值是 null。

'mid_on_find_prefix'
    指示查询 many to many 关联，中间表的字段包含在查询结果中时要加上什么前缀
    默认的 'mid_on_find_prefix' 是 'mid_'

'on_find'
    指示是否读取关联的记录

    true 或 'all'   - 读取所有关联记录
    false 或 'skip' - 跳过，不读取内容记录
    整数            - 仅读取指定个数的内容记录，例如 'on_find' = 5 表示仅读取每个作者的 5 个内容记录
    数组            - 包含读取起始位置和要读取的个数，例如 array($offset, $nums)

    对于所有类型的关联，'on_find' 的默认值都是 true

'on_find_order'
    指示按照什么排序规则查询关联的记录，如果为空字符串或 null，则表示查询关联时不排序

'on_find_fields'
    指示在读取关联记录时，只获取关联记录的哪些字段

'on_delete'
    指示在删除主表记录时，如何处理关联的记录

    true 或 'cascade'   - 删除所有的关联记录
    'set_null'          - 将关联记录的外键字段设置为 NULL
    'set_value'         - 将关联记录的外键字段设置为指定的值
    false 或 'skip'     - 不处理关联记录

    对于 belongs to 和 many to many 关联，'on_delete' 的默认值是 'skip'
    对于 has many 和 has one 关联，默认值则是 'cascade'

'on_delete_set_value'
    如果 'on_delete' 为 'set_value'，则通过 'on_delete_set_value' 指定要填充的值
    'on_delete_set_value' 的默认值为 null

'on_save'
    指示是否保存关联的记录

    true 或 'save'  - 根据关联记录是否具有主键值来决定是创建记录还是更新现有记录
    'create'        - 强制创建新记录
    'update'        - 强制更新记录
    'replace'       - 使用数据库的 replace 操作来尝试替换记录
    false 或 'skip' - 不处理关联记录
    'only_create'   - 仅仅保存需要创建的记录（根据是否具备主键值判断）
    'only_update'   - 仅仅保存需要更新的记录（根据是否具备主键值判断）

    对于 belongs to 和 many to many 关联，'on_save' 的默认值是 'skip'
    对于 has many 和 has one 关联，'on_save' 的默认值是 'save'
